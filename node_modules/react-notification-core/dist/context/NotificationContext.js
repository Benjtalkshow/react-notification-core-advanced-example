"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useNotifications = exports.NotificationProvider = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const fetchUtils_1 = require("../utils/fetchUtils");
const initialState = {
    notifications: [],
    unreadCount: 0,
    isLoading: false,
    error: null,
    lastUpdated: null,
};
const NotificationContext = (0, react_1.createContext)(undefined);
function notificationReducer(state, action) {
    switch (action.type) {
        case "FETCH_NOTIFICATIONS_REQUEST":
            return {
                ...state,
                isLoading: true,
                error: null,
            };
        case "FETCH_NOTIFICATIONS_SUCCESS":
            return {
                ...state,
                notifications: action.payload,
                unreadCount: action.payload.filter((notification) => !notification.read).length,
                isLoading: false,
                error: null,
                lastUpdated: new Date(),
            };
        case "FETCH_NOTIFICATIONS_FAILURE":
            return {
                ...state,
                isLoading: false,
                error: action.payload,
            };
        case "ADD_NOTIFICATION":
            return {
                ...state,
                notifications: [action.payload, ...state.notifications],
                unreadCount: state.unreadCount + (action.payload.read ? 0 : 1),
                lastUpdated: new Date(),
            };
        case "MARK_AS_READ":
            return {
                ...state,
                notifications: state.notifications.map((notification) => notification.id === action.payload ? { ...notification, read: true } : notification),
                unreadCount: state.unreadCount - (state.notifications.find((n) => n.id === action.payload && !n.read) ? 1 : 0),
                lastUpdated: new Date(),
            };
        case "MARK_ALL_AS_READ":
            return {
                ...state,
                notifications: state.notifications.map((notification) => ({ ...notification, read: true })),
                unreadCount: 0,
                lastUpdated: new Date(),
            };
        case "DELETE_NOTIFICATION":
            const deletedNotification = state.notifications.find((n) => n.id === action.payload);
            return {
                ...state,
                notifications: state.notifications.filter((notification) => notification.id !== action.payload),
                unreadCount: state.unreadCount - (deletedNotification && !deletedNotification.read ? 1 : 0),
                lastUpdated: new Date(),
            };
        case "CLEAR_ALL_NOTIFICATIONS":
            return {
                ...state,
                notifications: [],
                unreadCount: 0,
                lastUpdated: new Date(),
            };
        default:
            return state;
    }
}
const NotificationProvider = ({ children, fetchNotifications, onMarkAsRead, onMarkAllAsRead, onDeleteNotification, fetchOptions = { retryCount: 3, retryDelay: 1000, timeout: 10000 }, initialState: initialStateOverrides = {}, }) => {
    const [state, dispatch] = (0, react_1.useReducer)(notificationReducer, { ...initialState, ...initialStateOverrides });
    const fetchOptionsRef = (0, react_1.useRef)(fetchOptions);
    (0, react_1.useEffect)(() => {
        fetchOptionsRef.current = fetchOptions;
    }, [fetchOptions]);
    (0, react_1.useEffect)(() => {
        if (fetchNotifications) {
            loadNotifications();
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [fetchNotifications]);
    const loadNotifications = (0, react_1.useCallback)(async () => {
        if (!fetchNotifications)
            return;
        try {
            dispatch({ type: "FETCH_NOTIFICATIONS_REQUEST" });
            const notifications = await (0, fetchUtils_1.fetchWithRetry)(fetchNotifications, fetchOptionsRef.current);
            dispatch({ type: "FETCH_NOTIFICATIONS_SUCCESS", payload: notifications });
        }
        catch (error) {
            dispatch({
                type: "FETCH_NOTIFICATIONS_FAILURE",
                payload: error instanceof Error ? error.message : "Failed to fetch notifications",
            });
        }
    }, [fetchNotifications]);
    const markAsRead = (0, react_1.useCallback)(async (id) => {
        if (onMarkAsRead) {
            try {
                await onMarkAsRead(id);
            }
            catch (error) {
                console.error("Error marking notification as read:", error);
                throw error;
            }
        }
        dispatch({ type: "MARK_AS_READ", payload: id });
    }, [onMarkAsRead]);
    const markAllAsRead = (0, react_1.useCallback)(async () => {
        if (onMarkAllAsRead) {
            try {
                await onMarkAllAsRead();
            }
            catch (error) {
                console.error("Error marking all notifications as read:", error);
                throw error;
            }
        }
        dispatch({ type: "MARK_ALL_AS_READ" });
    }, [onMarkAllAsRead]);
    const deleteNotification = (0, react_1.useCallback)(async (id) => {
        if (onDeleteNotification) {
            try {
                await onDeleteNotification(id);
            }
            catch (error) {
                console.error("Error deleting notification:", error);
                throw error;
            }
        }
        dispatch({ type: "DELETE_NOTIFICATION", payload: id });
    }, [onDeleteNotification]);
    const addNotification = (0, react_1.useCallback)((notification) => {
        dispatch({ type: "ADD_NOTIFICATION", payload: notification });
    }, []);
    const clearAllNotifications = (0, react_1.useCallback)(() => {
        dispatch({ type: "CLEAR_ALL_NOTIFICATIONS" });
    }, []);
    const refreshNotifications = (0, react_1.useCallback)(async () => {
        await loadNotifications();
    }, [loadNotifications]);
    const value = {
        ...state,
        addNotification,
        markAsRead,
        markAllAsRead,
        deleteNotification,
        clearAllNotifications,
        refreshNotifications,
    };
    return (0, jsx_runtime_1.jsx)(NotificationContext.Provider, { value: value, children: children });
};
exports.NotificationProvider = NotificationProvider;
const useNotifications = () => {
    const context = (0, react_1.useContext)(NotificationContext);
    if (context === undefined) {
        throw new Error("useNotifications must be used within a NotificationProvider");
    }
    return context;
};
exports.useNotifications = useNotifications;
//# sourceMappingURL=NotificationContext.js.map