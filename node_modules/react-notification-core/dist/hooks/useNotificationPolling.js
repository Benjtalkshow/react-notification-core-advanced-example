"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useNotificationPolling = void 0;
const react_1 = require("react");
const NotificationContext_1 = require("../context/NotificationContext");
const fetchUtils_1 = require("../utils/fetchUtils");
/**
 * Hook for polling notifications at regular intervals
 */
const useNotificationPolling = ({ enabled = true, interval = 60000, // Default to 1 minute
onError, retryCount = 3, retryDelay = 1000, } = {}) => {
    const { refreshNotifications } = (0, NotificationContext_1.useNotifications)();
    const intervalRef = (0, react_1.useRef)(null);
    const isPollingRef = (0, react_1.useRef)(enabled);
    const fetchNotifications = (0, react_1.useCallback)(async () => {
        try {
            await (0, fetchUtils_1.fetchWithRetry)(refreshNotifications, { retryCount, retryDelay });
        }
        catch (error) {
            if (onError) {
                onError(error);
            }
            else {
                console.error("Error polling notifications:", error);
            }
        }
    }, [refreshNotifications, retryCount, retryDelay, onError]);
    // Set up and clean up polling
    (0, react_1.useEffect)(() => {
        isPollingRef.current = enabled;
        const setupPolling = () => {
            if (!enabled)
                return;
            // Initial fetch
            fetchNotifications();
            // Set up interval
            intervalRef.current = setInterval(fetchNotifications, interval);
        };
        setupPolling();
        // Clean up
        return () => {
            if (intervalRef.current) {
                clearInterval(intervalRef.current);
                intervalRef.current = null;
            }
        };
    }, [enabled, interval, fetchNotifications]);
    // Return control functions
    return {
        refresh: fetchNotifications,
        stopPolling: (0, react_1.useCallback)(() => {
            isPollingRef.current = false;
            if (intervalRef.current) {
                clearInterval(intervalRef.current);
                intervalRef.current = null;
            }
        }, []),
        startPolling: (0, react_1.useCallback)(() => {
            isPollingRef.current = true;
            if (intervalRef.current) {
                clearInterval(intervalRef.current);
            }
            fetchNotifications();
            intervalRef.current = setInterval(fetchNotifications, interval);
        }, [fetchNotifications, interval]),
        isPolling: () => isPollingRef.current,
    };
};
exports.useNotificationPolling = useNotificationPolling;
//# sourceMappingURL=useNotificationPolling.js.map