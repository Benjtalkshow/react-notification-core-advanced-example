"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterNotifications = exports.groupNotificationsByDate = exports.formatTimestamp = exports.fetchWithRetry = void 0;
/**
 * Fetches data with retry capability
 * @param fetchFn The function to fetch data
 * @param options Options for retrying
 * @returns The fetched data
 */
async function fetchWithRetry(fetchFn, options = {}) {
    const { retryCount = 3, retryDelay = 1000, timeout = 10000 } = options;
    let lastError = null;
    for (let attempt = 0; attempt <= retryCount; attempt++) {
        try {
            // Create a timeout promise
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => {
                    reject(new Error(`Request timed out after ${timeout}ms`));
                }, timeout);
            });
            // Race between the fetch and the timeout
            const result = (await Promise.race([fetchFn(), timeoutPromise]));
            return result;
        }
        catch (error) {
            lastError = error instanceof Error ? error : new Error(String(error));
            // If this was the last attempt, throw the error
            if (attempt === retryCount) {
                throw lastError;
            }
            // Wait before retrying (with exponential backoff)
            const delay = retryDelay * Math.pow(2, attempt);
            await new Promise((resolve) => setTimeout(resolve, delay));
        }
    }
    // This should never be reached due to the throw in the loop,
    // but TypeScript needs it for type safety
    throw lastError || new Error("Unknown error during fetch with retry");
}
exports.fetchWithRetry = fetchWithRetry;
/**
 * Formats a timestamp into a human-readable string
 * @param timestamp The timestamp to format
 * @returns A formatted string like "2 minutes ago"
 */
function formatTimestamp(timestamp) {
    const date = typeof timestamp === "string" ? new Date(timestamp) : timestamp;
    const now = new Date();
    const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);
    if (diffInSeconds < 60) {
        return "just now";
    }
    else if (diffInSeconds < 3600) {
        const minutes = Math.floor(diffInSeconds / 60);
        return `${minutes} ${minutes === 1 ? "minute" : "minutes"} ago`;
    }
    else if (diffInSeconds < 86400) {
        const hours = Math.floor(diffInSeconds / 3600);
        return `${hours} ${hours === 1 ? "hour" : "hours"} ago`;
    }
    else if (diffInSeconds < 604800) {
        const days = Math.floor(diffInSeconds / 86400);
        return `${days} ${days === 1 ? "day" : "days"} ago`;
    }
    else {
        return date.toLocaleDateString();
    }
}
exports.formatTimestamp = formatTimestamp;
/**
 * Groups notifications by date
 * @param notifications Array of notifications
 * @returns Object with dates as keys and arrays of notifications as values
 */
function groupNotificationsByDate(notifications) {
    return notifications.reduce((groups, notification) => {
        const date = typeof notification.timestamp === "string" ? new Date(notification.timestamp) : notification.timestamp;
        const dateStr = date.toDateString();
        if (!groups[dateStr]) {
            groups[dateStr] = [];
        }
        groups[dateStr].push(notification);
        return groups;
    }, {});
}
exports.groupNotificationsByDate = groupNotificationsByDate;
/**
 * Filters notifications based on criteria
 * @param notifications Array of notifications
 * @param criteria Filter criteria
 * @returns Filtered array of notifications
 */
function filterNotifications(notifications, criteria) {
    return notifications.filter((notification) => {
        var _a, _b;
        // Filter by read status
        if (criteria.read !== undefined && notification.read !== criteria.read) {
            return false;
        }
        // Filter by type
        if (criteria.type && notification.type !== criteria.type) {
            return false;
        }
        // Filter by search term
        if (criteria.search) {
            const searchLower = criteria.search.toLowerCase();
            const titleMatch = (_a = notification.title) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes(searchLower);
            const messageMatch = (_b = notification.message) === null || _b === void 0 ? void 0 : _b.toLowerCase().includes(searchLower);
            if (!titleMatch && !messageMatch) {
                return false;
            }
        }
        // Filter by date range
        if (criteria.fromDate || criteria.toDate) {
            const notifDate = typeof notification.timestamp === "string" ? new Date(notification.timestamp) : notification.timestamp;
            if (criteria.fromDate && notifDate < criteria.fromDate) {
                return false;
            }
            if (criteria.toDate) {
                // Add one day to include the end date fully
                const toDateEnd = new Date(criteria.toDate);
                toDateEnd.setDate(toDateEnd.getDate() + 1);
                if (notifDate > toDateEnd) {
                    return false;
                }
            }
        }
        return true;
    });
}
exports.filterNotifications = filterNotifications;
//# sourceMappingURL=fetchUtils.js.map